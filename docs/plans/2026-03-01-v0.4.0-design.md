# v0.4.0 Design — Prowlarr Integration + Season Pack Intelligence

**Date:** 2026-03-01
**Status:** Approved
**PRD Features:** #8 (Prowlarr Integration), #9 (Season Pack Intelligence)

---

## Feature 8: Prowlarr Integration & Indexer-Aware Rate Limiting

### Problem

Blanket per-instance rate limits don't account for individual indexer API limits. Being too aggressive gets you banned; too conservative means missing content. Prowlarr already knows each indexer's limits — Splintarr should read them.

### Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Rate limit fallback | Use Prowlarr limits if set, fall back to per-instance `rate_limit` | Most pragmatic. Many users won't configure Prowlarr limits. |
| Usage tracking | Read from Prowlarr `/api/v1/indexerstats` | Single source of truth. No local state to maintain. Accounts for all apps using the same indexers. |
| Data model | Separate `prowlarr_config` table, not a new instance type | Prowlarr is infrastructure config, not a search target. |

### Data Model

New table: `prowlarr_config`

| Column | Type | Notes |
|--------|------|-------|
| id | Integer PK | |
| user_id | Integer FK(users) | |
| url | String | Prowlarr base URL |
| encrypted_api_key | Text | Fernet-encrypted, same pattern as Instance |
| verify_ssl | Boolean | Default True |
| sync_interval_minutes | Integer | Default 60 |
| is_active | Boolean | Default True |
| last_sync_at | DateTime | Nullable |
| created_at | DateTime | |

No local indexer tables. Indexer data, stats, and app-to-indexer mappings are read live from the Prowlarr API — Prowlarr is the source of truth.

### Prowlarr API Endpoints Used

| Endpoint | Purpose |
|----------|---------|
| `GET /api/v1/indexer` | List indexers with `QueryLimit`, `GrabLimit`, `LimitsUnit` from `fields` |
| `GET /api/v1/applications` | App-to-tag mappings (which indexers sync to which Sonarr/Radarr) |
| `GET /api/v1/indexerstats` | Usage counts (queries, grabs) per indexer per time window |
| `GET /api/v1/indexerstatus` | Circuit-breaker state (disabled indexers) |

Authentication: `X-Api-Key` header, same pattern as Sonarr/Radarr clients.

### Service Layer

**`ProwlarrClient`** (extends `BaseArrClient`):
- `get_indexers()` — parses `QueryLimit`, `GrabLimit`, `LimitsUnit` from the nested `fields` array
- `get_applications()` — returns app implementations, URLs, and tag lists
- `get_indexer_stats(start_date, end_date)` — per-indexer query/grab counts
- `get_indexer_status()` — circuit-breaker state (disabled indexers)

**`IndexerRateLimitService`**:

Before each search run, resolves the effective rate limit for a Sonarr/Radarr instance:

1. Fetch Prowlarr config for the user. If not configured or inactive, return `instance.rate_limit`.
2. Call `get_indexers()`, `get_applications()`, `get_indexer_stats()`.
3. Match the Sonarr/Radarr instance to a Prowlarr application by comparing the instance URL to the application's `fields` (the downstream app URL field).
4. Find connected indexers via tag intersection (if application has no tags, all indexers match).
5. For each indexer with `QueryLimit` set, compute remaining budget: `QueryLimit - numberOfQueries` within the current `LimitsUnit` window (hour or day).
6. Skip any indexer where `disabledTill` is in the future (circuit-broken).
7. Effective limit = minimum remaining budget across all connected, non-disabled indexers.
8. If no indexers have limits configured, fall back to `instance.rate_limit`.

### Search Queue Integration

In `SearchQueueManager.execute_queue()`, before the search loop:
- Call `IndexerRateLimitService.get_effective_limit(instance_id, user_id)`
- Cap `max_items_per_run` for this execution to not exceed the remaining API budget
- Log the effective limit at INFO: `search_queue_rate_limit_resolved`

### UI

- **Settings page:** "Prowlarr" section with URL, API key, test connection button, sync interval
- **Dashboard:** Indexer health widget — table showing per-indexer name, status (enabled/disabled), queries used/limit, grabs used/limit
- **Instance detail:** Show which Prowlarr indexers are connected and their current budget

### Error Handling

- Prowlarr unreachable: log WARNING, fall back to per-instance rate limit, continue searching
- Prowlarr API key invalid: log ERROR, show warning banner on dashboard
- No matching application found for a Sonarr/Radarr instance: log DEBUG, fall back to per-instance rate limit

---

## Feature 9: Season Pack Intelligence (Sonarr Only)

### Problem

Individual episode searches fail for older content where only season packs exist on indexers. This wastes API calls searching episode-by-episode when a single season pack search would succeed. Most requested Sonarr feature (GitHub #4229).

### Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Threshold scope | Per-queue | Matches existing per-queue config pattern (cooldown_mode, max_items_per_run). Aggressive queues may want lower threshold. |
| Default threshold | 3 missing episodes | PRD default. Low enough to catch most season pack opportunities, high enough to avoid unnecessary season searches for 1-2 missing episodes. |

### Data Model

Add to `SearchQueue` model:

| Column | Type | Notes |
|--------|------|-------|
| season_pack_enabled | Boolean | Default False |
| season_pack_threshold | Integer | Default 3, min 2, max 50 |

### Search Execution Logic

In `SearchQueueManager._search_paginated_records()`, after scoring and filtering but before issuing searches:

1. If `queue.season_pack_enabled` is False or instance is Radarr: skip, search normally.
2. Group the remaining items by `(series_id, season_number)`.
3. For any group where `count >= queue.season_pack_threshold`:
   - Issue one `SeasonSearch` command via Sonarr API instead of N `EpisodeSearch` commands.
   - Log at INFO: `season_pack_search_triggered` with `series_id`, `season_number`, `episode_count`.
   - Count as 1 API call against the rate budget (not N).
   - Mark all episodes in the group as searched (update `search_attempts`, `last_searched_at`).
4. Remaining items (groups below threshold) search individually as normal.

### Sonarr Client

Add method to `SonarrClient`:
- `season_search(series_id: int, season_number: int)` — `POST /api/v3/command` with `{"name": "SeasonSearch", "seriesId": ..., "seasonNumber": ...}`

### Search History

Season pack searches are recorded in `SearchHistory.search_metadata` with `action: "season_pack"` and the list of episode IDs covered. This allows the feedback loop (Feature #12) to check grab status for all episodes in the pack.

### UI

- **Create Queue modal:** "Season Pack Search" toggle (only shown when the selected instance is Sonarr), threshold number input (shown when toggle is on)
- **Queue detail:** Search log shows "Season Pack" as the action type, with episode count
- **Presets:** Update built-in presets to include `season_pack_enabled: false` (conservative default)

### Edge Cases

- **Mixed seasons:** If a series has 2 missing from S01 and 4 missing from S02 (threshold=3), only S02 gets a season pack search. S01 episodes search individually.
- **Already grabbed:** If a season pack search triggers a grab, the feedback loop detects it per-episode via the existing `_check_sonarr_episode` path.
- **Cutoff Unmet:** `SeasonSearch` in Sonarr respects quality profiles and monitored status, so it correctly handles cutoff-unmet without re-downloading deleted episodes.
